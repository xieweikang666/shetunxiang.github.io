{"pages":[],"posts":[{"title":"css清除浮动","text":"清除浮动 实际上就是 父级div高度难以确定，子元素浮动导致父div高度崩塌，影响了页面其他元素的布局 代码结构12345678&lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;big&quot;&gt;big&lt;/div&gt; &lt;div class=&quot;small&quot;&gt;smal&lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt;&lt;/body&gt; 12345678910111213141516171819202122&lt;style type=&quot;text/css&quot;&gt; .big{ float: left; width: 300px; height: 200px; background: #0000FF; } .small{ float: left; width: 200px; height: 100px; background: #FFA500; } .footer{ width: 400px; height: 200px; background: #FF0000; } .clear{ clear: both; }&lt;/style&gt; 如图此时还未设置big 和 small 浮动 此时 设置 big 和small float:left 父div高度崩塌 footer元素跑了上去 解决方案1.在父级div中最后一行增加一个div 1&lt;div class=&quot;clear&quot; style=&apos;clear:both;&apos;&gt;&lt;/div&gt; 2.在父级div中增加 overflow:hidden； 3.啥都不做，给浮动元素后的元素增加 clear:both; 4.使用css的:after伪元素 ​ 给浮动元素的容器增加一个:after伪元素实现一个元素末尾添加一个看不见的块元素来清理浮动 1234567891011.father{ zoom: 1; /* overflow: hidden; */}.father:after{ content: &quot;020&quot;; display: block; height: 0; clear: both; visibility: hidden;}","link":"/2019/10/31/css%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"},{"title":"Css学习笔记1","text":"Css盒子模型​ 盒子模型分为IE盒子模型和标准盒子模型 ​ box-sizing有3个值: border-box /padding-box /content-box ​ 标准盒子模型： ​ IE盒子模型： 标准盒子模型的盒子宽度：width IE盒子模型的盒子宽度：左右border+左右padding+width 在CSS3中引入了box-sizing属性，box-sizing:content-box;表示标准的盒子模型，box-sizing:border-box表示的是IE盒子模型 img的title和alt有什么区别？ title为该属性提供信息，通常当鼠标滑动到元素上的时候显示； alt用于图片无法加载的时候显示信息","link":"/2019/10/30/Css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"},{"title":"JS学习笔记1","text":"JavaScript基本数据类型字符串、数字、布尔值、数组、对象、null、undefined vue中$refs的基本用法ref 有三种用法： 　　1、ref 加在普通的元素上，用this.ref.name 获取到的是dom元素 　　2、ref 加在子组件上，用this.ref.name 获取到的是组件实例，可以使用组件的所有方法。 　　3、如何利用 v-for 和 ref 获取一组数组或者dom 节点 1234&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; ref=&quot;input1&quot;/&gt; &lt;button @click=&quot;add&quot;&gt;添加&lt;/button&gt;&lt;/div&gt; 1234567891011&lt;script&gt;new Vue({ el: &quot;#app&quot;, methods:{ add:function(){ //this.$refs.input1减少获取dom节点的消耗 this.$refs.input1.value =&quot;22&quot;; } }})&lt;/script&gt; 一般来说，获取DOM元素，需要使用document.querySelector(“.input1”)来获取该DOM节点，然后再获取input1的值。 但是用ref绑定之后，就不需要再去获取dom节点了，直接在input上绑定 input ，然后在$refs中调用就行 这样子调用： this.$refs.input1 这样子就可以减少获取dom节点对性能的消耗了","link":"/2019/10/24/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"},{"title":"测试文章","text":"这篇是测试文章 这里是标题测试使用 testing","link":"/2019/10/24/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"},{"title":"事件传播以及事件委托","text":"事件传播分三个阶段 事件委托优化代码性能 事件的传播 事件传播分为三个阶段 1.捕获阶段 在捕获阶段时从最外层的祖先元素，向目标元素进行事件捕获，但是默认不会此时不会触发事件 2.目标阶段 事件捕获到目标元素，捕获结束开始在目标元素上触发事件 3.冒泡阶段 事件从目标元素向它的祖先元素传递，依次触发祖先元素上的事件 注:如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true，一般情况下我们不希望在捕获阶段触发事件，所以该值默认为false js中的事件委托参考资料：https://www.cnblogs.com/liugang-vip/p/5616484.html 事件代理资料：https://blog.csdn.net/qq_38128179/article/details/86293394 ​ 事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件 为什么要用事件委托？​ 一般来说，dom需要有事件处理程序，我们都会直接给它设事件处理程序就好了，那如果是很多的dom需要添加事件处理呢？比如我们有100个li，每个li都有相同的click点击事件，可能我们会用for循环的方法，来遍历所有的li，然后给它们添加事件，那这么做会存在什么影响呢？ ​ 在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能； 123456&lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;add&quot; value=&quot;添加&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;remove&quot; value=&quot;删除&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;move&quot; value=&quot;移动&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;select&quot; value=&quot;选择&quot; /&gt; &lt;/div&gt; 1234567891011121314151617181920window.onload = function(){ var Add = document.getElementById(&quot;add&quot;); var Remove = document.getElementById(&quot;remove&quot;); var Move = document.getElementById(&quot;move&quot;); var Select = document.getElementById(&quot;select&quot;); Add.onclick = function(){ alert(&apos;添加&apos;); }; Remove.onclick = function(){ alert(&apos;删除&apos;); }; Move.onclick = function(){ alert(&apos;移动&apos;); }; Select.onclick = function(){ alert(&apos;选择&apos;); } } 4个按钮，点击每一个做不同的操作，那么至少需要4次dom操作，如果用事件委托，能进行优化吗？ 123456789101112131415161718192021222324window.onload = function(){ var oBox = document.getElementById(&quot;box&quot;); oBox.onclick = function (ev) { var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLocaleLowerCase() == &apos;input&apos;){ switch(target.id){ case &apos;add&apos; : alert(&apos;添加&apos;); break; case &apos;remove&apos; : alert(&apos;删除&apos;); break; case &apos;move&apos; : alert(&apos;移动&apos;); break; case &apos;select&apos; : alert(&apos;选择&apos;); break; } } } } 用事件委托就可以只用一次dom操作就能完成所有的效果 例子：鼠标移入背景色变红色，移出变白色 新增节点 1234567&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;btn&quot; value=&quot;添加&quot; /&gt; &lt;ul id=&quot;ul1&quot;&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt; &lt;/ul&gt; 1234567891011121314151617181920212223window.onload = function(){ var oBtn = document.getElementById(&quot;btn&quot;); var oUl = document.getElementById(&quot;ul1&quot;); var aLi = oUl.getElementsByTagName(&apos;li&apos;); var num = 4; //鼠标移入变红，移出变白 for(var i=0; i&lt;aLi.length;i++){ aLi[i].onmouseover = function(){ this.style.background = &apos;red&apos;; }; aLi[i].onmouseout = function(){ this.style.background = &apos;#fff&apos;; } } //添加新节点 oBtn.onclick = function(){ num++; var oLi = document.createElement(&apos;li&apos;); oLi.innerHTML = 111*num; oUl.appendChild(oLi); }; } 如果这样子写的话，新增的li是没有事件的，背景色不会变红，这说明新增子节点的时候，事件没有一起添加进去，这不是我们想要的结果，那我们可以先用函数的方式包装起来，命名为mHover 代码如下： 123456789101112131415161718192021222324252627window.onload = function(){ var oBtn = document.getElementById(&quot;btn&quot;); var oUl = document.getElementById(&quot;ul1&quot;); var aLi = oUl.getElementsByTagName(&apos;li&apos;); var num = 4; function mHover () { //鼠标移入变红，移出变白 for(var i=0; i&lt;aLi.length;i++){ aLi[i].onmouseover = function(){ this.style.background = &apos;red&apos;; }; aLi[i].onmouseout = function(){ this.style.background = &apos;#fff&apos;; } } } mHover (); //添加新节点 oBtn.onclick = function(){ num++; var oLi = document.createElement(&apos;li&apos;); oLi.innerHTML = 111*num; oUl.appendChild(oLi); mHover (); }; } 虽然功能实现了，看着还挺好，但实际上无疑是又增加了一个dom操作，在优化性能方面是不可取的，那么有事件委托的方式，能做到优化，代码如下： 1234567891011121314151617181920212223242526272829303132window.onload = function(){ var oBtn = document.getElementById(&quot;btn&quot;); var oUl = document.getElementById(&quot;ul1&quot;); var aLi = oUl.getElementsByTagName(&apos;li&apos;); var num = 4; //事件委托，添加的子元素也有事件 oUl.onmouseover = function(ev){ var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == &apos;li&apos;){ target.style.background = &quot;red&quot;; } }; oUl.onmouseout = function(ev){ var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == &apos;li&apos;){ target.style.background = &quot;#fff&quot;; } }; //添加新节点 oBtn.onclick = function(){ num++; var oLi = document.createElement(&apos;li&apos;); oLi.innerHTML = 111*num; oUl.appendChild(oLi); }; } 总结： 什么样的事件可以使用事件委托，什么样的不行呢？ 适合用事件委托的事件有:click mousedown mouseup keydown keyup keypress 值得注意的是，mouseover和mouseout虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。 不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，在不如说focus，blur之类的，本身就没用冒泡的特性，自然就不能用事件委托了。","link":"/2019/10/30/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"}],"tags":[{"name":"study","slug":"study","link":"/tags/study/"},{"name":"test","slug":"test","link":"/tags/test/"}],"categories":[{"name":"Css学习","slug":"Css学习","link":"/categories/Css%E5%AD%A6%E4%B9%A0/"},{"name":"JS学习","slug":"JS学习","link":"/categories/JS%E5%AD%A6%E4%B9%A0/"},{"name":"测试使用","slug":"测试使用","link":"/categories/%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/"}]}